// Note: This file is generated using the pioasm web tool.
// You can also use the rp2040 sdk and the cmake build system to generate it.

// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------------------ //
// quadrature_encoder //
// ------------------ //

#define quadrature_encoder_wrap_target 15
#define quadrature_encoder_wrap 28

static const uint16_t quadrature_encoder_program_instructions[] = {
        0x000f, //  0: jmp    15
        0x000e, //  1: jmp    14
        0x001a, //  2: jmp    26
        0x000f, //  3: jmp    15
        0x001a, //  4: jmp    26
        0x000f, //  5: jmp    15
        0x000f, //  6: jmp    15
        0x000e, //  7: jmp    14
        0x000e, //  8: jmp    14
        0x000f, //  9: jmp    15
        0x000f, // 10: jmp    15
        0x001a, // 11: jmp    26
        0x000f, // 12: jmp    15
        0x001a, // 13: jmp    26
        0x008f, // 14: jmp    y--, 15
        //     .wrap_target
        0xe020, // 15: set    x, 0
        0x8080, // 16: pull   noblock
        0xa027, // 17: mov    x, osr
        0xa0e6, // 18: mov    osr, isr
        0x0036, // 19: jmp    !x, 22
        0xa0c2, // 20: mov    isr, y
        0x8020, // 21: push   block
        0xa0c3, // 22: mov    isr, null
        0x40e2, // 23: in     osr, 2
        0x4002, // 24: in     pins, 2
        0xa0a6, // 25: mov    pc, isr
        0xa02a, // 26: mov    x, !y
        0x005c, // 27: jmp    x--, 28
        0xa049, // 28: mov    y, !x
        //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program quadrature_encoder_program = {
        .instructions = quadrature_encoder_program_instructions,
        .length = 29,
        .origin = 0,
};

static inline pio_sm_config quadrature_encoder_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + quadrature_encoder_wrap_target, offset + quadrature_encoder_wrap);
    return c;
}

#include "hardware/clocks.h"
#include "hardware/gpio.h"
//
// clock_divisor is used to lower the clock of the state machine, thus reducing the
// bandwidth of this encoder counter.  Setting the value to 1 gives the full bandwidth.
// With the Pico running at 133Mhz and a clock_divisor of 1, the max count rate is
// about 12 million encoder_counts/second. Setting the divisor to 12 reduces the
// bandwidth to ~1 million counts/sec.  A value of 1200 sets the max rate to ~10K/sec.
// Reducing the bandwidth has the advantage of making the encoder more noise resistant
// and perhaps lower the Pico's power usage.
//
static inline void quadrature_encoder_program_init(PIO pio, uint sm, uint offset, uint pin, int clock_divisor)
{
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 2, false);
    pio_gpio_init(pio, pin);
    gpio_pull_up(pin);
    pio_sm_config c = quadrature_encoder_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pin); // for WAIT, IN
    sm_config_set_jmp_pin(&c, pin); // for JMP
    // shift to left, autopull disabled
    sm_config_set_in_shift(&c, false, false, 32);
    // don't join FIFO's
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_NONE);
    if ((clock_divisor >= 1) && (clock_divisor <= 100000))
        sm_config_set_clkdiv(&c, (float) clock_divisor);
    else
        sm_config_set_clkdiv(&c, 1.0);
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
// When requesting the current count we may have to wait a few cycles (average
// ~11 sysclk cycles) for the state machine to reply. If we are reading multiple
// encoders, we may request them all in one go and then fetch them all, thus
// avoiding doing the wait multiple times. If we are reading just one encoder,
// we can use the "get_count" function to request and wait
static inline void quadrature_encoder_request_count(PIO pio, uint sm)
{
    pio->txf[sm] = 1;
}
static inline int32_t quadrature_encoder_fetch_count(PIO pio, uint sm)
{
    while (pio_sm_is_rx_fifo_empty(pio, sm))
        tight_loop_contents();
    return pio->rxf[sm];
}
static inline int32_t quadrature_encoder_get_count(PIO pio, uint sm)
{
    quadrature_encoder_request_count(pio, sm);
    return quadrature_encoder_fetch_count(pio, sm);
}

#endif
